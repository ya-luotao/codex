# PR #2050: TUI: Show apply patch diff. Stack: [2/2]

- URL: https://github.com/openai/codex/pull/2050
- Author: aibrahim-oai
- Created: 2025-08-08 23:06:23 UTC
- Updated: 2025-08-12 01:33:08 UTC
- Changes: +363/-46, Files changed: 8, Commits: 17

## Description

Show the diff for apply patch

<img width="801" height="345" alt="image" src="https://github.com/user-attachments/assets/a15d6112-e83e-4612-a2bd-43285689a358" />


Stack:
-> #2050
#2049

## Full Diff

```diff
diff --git a/codex-rs/tui/src/chatwidget.rs b/codex-rs/tui/src/chatwidget.rs
index 173ab64af2..6719cfb7a7 100644
--- a/codex-rs/tui/src/chatwidget.rs
+++ b/codex-rs/tui/src/chatwidget.rs
@@ -46,6 +46,7 @@ use crate::bottom_pane::BottomPane;
 use crate::bottom_pane::BottomPaneParams;
 use crate::bottom_pane::CancellationEvent;
 use crate::bottom_pane::InputResult;
+use crate::common::DEFAULT_WRAP_COLS;
 use crate::history_cell::CommandOutput;
 use crate::history_cell::ExecCell;
 use crate::history_cell::HistoryCell;
@@ -223,7 +224,7 @@ impl ChatWidget<'_> {
             content_buffer: String::new(),
             answer_buffer: String::new(),
             running_commands: HashMap::new(),
-            live_builder: RowBuilder::new(80),
+            live_builder: RowBuilder::new(DEFAULT_WRAP_COLS.into()),
             current_stream: None,
             stream_header_emitted: false,
             live_max_rows: 3,
diff --git a/codex-rs/tui/src/common.rs b/codex-rs/tui/src/common.rs
new file mode 100644
index 0000000000..2c19b58706
--- /dev/null
+++ b/codex-rs/tui/src/common.rs
@@ -0,0 +1 @@
+pub(crate) const DEFAULT_WRAP_COLS: u16 = 80;
diff --git a/codex-rs/tui/src/diff_render.rs b/codex-rs/tui/src/diff_render.rs
index f536681732..ada84b89d6 100644
--- a/codex-rs/tui/src/diff_render.rs
+++ b/codex-rs/tui/src/diff_render.rs
@@ -1,3 +1,4 @@
+use crossterm::terminal;
 use ratatui::style::Color;
 use ratatui::style::Modifier;
 use ratatui::style::Style;
@@ -6,36 +7,44 @@ use ratatui::text::Span as RtSpan;
 use std::collections::HashMap;
 use std::path::PathBuf;
 
+use crate::common::DEFAULT_WRAP_COLS;
 use codex_core::protocol::FileChange;
 
-struct FileSummary {
-    display_path: String,
-    added: usize,
-    removed: usize,
+use crate::history_cell::PatchEventType;
+
+const SPACES_AFTER_LINE_NUMBER: usize = 6;
+
+// Internal representation for diff line rendering
+enum DiffLineType {
+    Insert,
+    Delete,
+    Context,
 }
 
 pub(crate) fn create_diff_summary(
     title: &str,
-    changes: HashMap<PathBuf, FileChange>,
+    changes: &HashMap<PathBuf, FileChange>,
+    event_type: PatchEventType,
 ) -> Vec<RtLine<'static>> {
-    let mut files: Vec<FileSummary> = Vec::new();
+    struct FileSummary {
+        display_path: String,
+        added: usize,
+        removed: usize,
+    }
 
-    // Count additions/deletions from a unified diff body
     let count_from_unified = |diff: &str| -> (usize, usize) {
         if let Ok(patch) = diffy::Patch::from_str(diff) {
-            let mut adds = 0usize;
-            let mut dels = 0usize;
-            for hunk in patch.hunks() {
-                for line in hunk.lines() {
-                    match line {
-                        diffy::Line::Insert(_) => adds += 1,
-                        diffy::Line::Delete(_) => dels += 1,
-                        _ => {}
-                    }
-                }
-            }
-            (adds, dels)
+            patch
+                .hunks()
+                .iter()
+                .flat_map(|h| h.lines())
+                .fold((0, 0), |(a, d), l| match l {
+                    diffy::Line::Insert(_) => (a + 1, d),
+                    diffy::Line::Delete(_) => (a, d + 1),
+                    _ => (a, d),
+                })
         } else {
+            // Fallback: manual scan to preserve counts even for unparsable diffs
             let mut adds = 0usize;
             let mut dels = 0usize;
             for l in diff.lines() {
@@ -52,29 +61,23 @@ pub(crate) fn create_diff_summary(
         }
     };
 
-    for (path, change) in &changes {
-        use codex_core::protocol::FileChange::*;
+    let mut files: Vec<FileSummary> = Vec::new();
+    for (path, change) in changes.iter() {
         match change {
-            Add { content } => {
-                let added = content.lines().count();
-                files.push(FileSummary {
-                    display_path: path.display().to_string(),
-                    added,
-                    removed: 0,
-                });
-            }
-            Delete => {
-                let removed = std::fs::read_to_string(path)
+            FileChange::Add { content } => files.push(FileSummary {
+                display_path: path.display().to_string(),
+                added: content.lines().count(),
+                removed: 0,
+            }),
+            FileChange::Delete => files.push(FileSummary {
+                display_path: path.display().to_string(),
+                added: 0,
+                removed: std::fs::read_to_string(path)
                     .ok()
                     .map(|s| s.lines().count())
-                    .unwrap_or(0);
-                files.push(FileSummary {
-                    display_path: path.display().to_string(),
-                    added: 0,
-                    removed,
-                });
-            }
-            Update {
+                    .unwrap_or(0),
+            }),
+            FileChange::Update {
                 unified_diff,
                 move_path,
             } => {
@@ -142,11 +145,278 @@ pub(crate) fn create_diff_summary(
         let mut line = RtLine::from(spans);
         let prefix = if idx == 0 { "  ⎿ " } else { "    " };
         line.spans.insert(0, prefix.into());
-        line.spans.iter_mut().for_each(|span| {
-            span.style = span.style.add_modifier(Modifier::DIM);
-        });
+        line.spans
+            .iter_mut()
+            .for_each(|span| span.style = span.style.add_modifier(Modifier::DIM));
         out.push(line);
     }
 
+    let show_details = matches!(
+        event_type,
+        PatchEventType::ApplyBegin {
+            auto_approved: true
+        } | PatchEventType::ApprovalRequest
+    );
+
+    if show_details {
+        out.extend(render_patch_details(changes));
+    }
+
     out
 }
+
+fn render_patch_details(changes: &HashMap<PathBuf, FileChange>) -> Vec<RtLine<'static>> {
+    let mut out: Vec<RtLine<'static>> = Vec::new();
+    let term_cols: usize = terminal::size()
+        .map(|(w, _)| w as usize)
+        .unwrap_or(DEFAULT_WRAP_COLS.into());
+
+    for (index, (path, change)) in changes.iter().enumerate() {
+        let is_first_file = index == 0;
+        // Add separator only between files (not at the very start)
+        if !is_first_file {
+            out.push(RtLine::from(vec![
+                RtSpan::raw("    "),
+                RtSpan::styled("...", style_dim()),
+            ]));
+        }
+        match change {
+            FileChange::Add { content } => {
+                for (i, raw) in content.lines().enumerate() {
+                    let ln = i + 1;
+                    out.extend(push_wrapped_diff_line(
+                        ln,
+                        DiffLineType::Insert,
+                        raw,
+                        term_cols,
+                    ));
+                }
+            }
+            FileChange::Delete => {
+                let original = std::fs::read_to_string(path).unwrap_or_default();
+                for (i, raw) in original.lines().enumerate() {
+                    let ln = i + 1;
+                    out.extend(push_wrapped_diff_line(
+                        ln,
+                        DiffLineType::Delete,
+                        raw,
+                        term_cols,
+                    ));
+                }
+            }
+            FileChange::Update {
+                unified_diff,
+                move_path: _,
+            } => {
+                if let Ok(patch) = diffy::Patch::from_str(unified_diff) {
+                    for h in patch.hunks() {
+                        let mut old_ln = h.old_range().start();
+                        let mut new_ln = h.new_range().start();
+                        for l in h.lines() {
+                            match l {
+                                diffy::Line::Insert(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    out.extend(push_wrapped_diff_line(
+                                        new_ln,
+                                        DiffLineType::Insert,
+                                        s,
+                                        term_cols,
+                                    ));
+                                    new_ln += 1;
+                                }
+                                diffy::Line::Delete(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    out.extend(push_wrapped_diff_line(
+                                        old_ln,
+                                        DiffLineType::Delete,
+                                        s,
+                                        term_cols,
+                                    ));
+                                    old_ln += 1;
+                                }
+                                diffy::Line::Context(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    out.extend(push_wrapped_diff_line(
+                                        new_ln,
+                                        DiffLineType::Context,
+                                        s,
+                                        term_cols,
+                                    ));
+                                    old_ln += 1;
+                                    new_ln += 1;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        out.push(RtLine::from(RtSpan::raw("")));
+    }
+
+    out
+}
+
+fn push_wrapped_diff_line(
+    line_number: usize,
+    kind: DiffLineType,
+    text: &str,
+    term_cols: usize,
+) -> Vec<RtLine<'static>> {
+    let indent = "    ";
+    let ln_str = line_number.to_string();
+    let mut remaining_text: &str = text;
+
+    // Reserve a fixed number of spaces after the line number so that content starts
+    // at a consistent column. The sign ("+"/"-") is rendered as part of the content
+    // with the same background as the edit, not as a separate dimmed column.
+    let gap_after_ln = SPACES_AFTER_LINE_NUMBER.saturating_sub(ln_str.len());
+    let first_prefix_cols = indent.len() + ln_str.len() + gap_after_ln;
+    let cont_prefix_cols = indent.len() + ln_str.len() + gap_after_ln;
+
+    let mut first = true;
+    let (sign_opt, bg_style) = match kind {
+        DiffLineType::Insert => (Some('+'), Some(style_add())),
+        DiffLineType::Delete => (Some('-'), Some(style_del())),
+        DiffLineType::Context => (None, None),
+    };
+    let mut lines: Vec<RtLine<'static>> = Vec::new();
+    while !remaining_text.is_empty() {
+        let prefix_cols = if first {
+            first_prefix_cols
+        } else {
+            cont_prefix_cols
+        };
+        // Fit the content for the current terminal row:
+        // compute how many columns are available after the prefix, then split
+        // at a UTF-8 character boundary so this row's chunk fits exactly.
+        let available_content_cols = term_cols.saturating_sub(prefix_cols).max(1);
+        let split_at_byte_index = remaining_text
+            .char_indices()
+            .nth(available_content_cols)
+            .map(|(i, _)| i)
+            .unwrap_or_else(|| remaining_text.len());
+        let (chunk, rest) = remaining_text.split_at(split_at_byte_index);
+        remaining_text = rest;
+
+        if first {
+            let mut spans: Vec<RtSpan<'static>> = Vec::new();
+            spans.push(RtSpan::raw(indent));
+            spans.push(RtSpan::styled(ln_str.clone(), style_dim()));
+            spans.push(RtSpan::raw(" ".repeat(gap_after_ln)));
+
+            // Prefix the content with the sign if it is an insertion or deletion, and color
+            // the sign with the same background as the edited text.
+            let display_chunk = match sign_opt {
+                Some(sign_char) => format!("{sign_char}{chunk}"),
+                None => chunk.to_string(),
+            };
+
+            let content_span = match bg_style {
+                Some(style) => RtSpan::styled(display_chunk, style),
+                None => RtSpan::raw(display_chunk),
+            };
+            spans.push(content_span);
+            lines.push(RtLine::from(spans));
+            first = false;
+        } else {
+            let hang_prefix = format!(
+                "{indent}{}{}",
+                " ".repeat(ln_str.len()),
+                " ".repeat(gap_after_ln)
+            );
+            let content_span = match bg_style {
+                Some(style) => RtSpan::styled(chunk.to_string(), style),
+                None => RtSpan::raw(chunk.to_string()),
+            };
+            lines.push(RtLine::from(vec![RtSpan::raw(hang_prefix), content_span]));
+        }
+    }
+    lines
+}
+
+fn style_dim() -> Style {
+    Style::default().add_modifier(Modifier::DIM)
+}
+
+fn style_add() -> Style {
+    Style::default().bg(Color::Green)
+}
+
+fn style_del() -> Style {
+    Style::default().bg(Color::Red)
+}
+
+#[allow(clippy::expect_used)]
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use crate::history_cell::HistoryCell;
+    use crate::text_block::TextBlock;
+    use insta::assert_snapshot;
+    use ratatui::Terminal;
+    use ratatui::backend::TestBackend;
+
+    fn snapshot_lines(name: &str, lines: Vec<RtLine<'static>>, width: u16, height: u16) {
+        let mut terminal = Terminal::new(TestBackend::new(width, height)).expect("terminal");
+        let cell = HistoryCell::PendingPatch {
+            view: TextBlock::new(lines),
+        };
+        terminal
+            .draw(|f| f.render_widget_ref(&cell, f.area()))
+            .expect("draw");
+        assert_snapshot!(name, terminal.backend());
+    }
+
+    #[test]
+    fn ui_snapshot_add_details() {
+        let mut changes: HashMap<PathBuf, FileChange> = HashMap::new();
+        changes.insert(
+            PathBuf::from("README.md"),
+            FileChange::Add {
+                content: "first line\nsecond line\n".to_string(),
+            },
+        );
+
+        let lines =
+            create_diff_summary("proposed patch", &changes, PatchEventType::ApprovalRequest);
+
+        snapshot_lines("add_details", lines, 80, 10);
+    }
+
+    #[test]
+    fn ui_snapshot_update_details_with_rename() {
+        let mut changes: HashMap<PathBuf, FileChange> = HashMap::new();
+
+        let original = "line one\nline two\nline three\n";
+        let modified = "line one\nline two changed\nline three\n";
+        let patch = diffy::create_patch(original, modified).to_string();
+
+        changes.insert(
+            PathBuf::from("src/lib.rs"),
+            FileChange::Update {
+                unified_diff: patch,
+                move_path: Some(PathBuf::from("src/lib_new.rs")),
+            },
+        );
+
+        let lines =
+            create_diff_summary("proposed patch", &changes, PatchEventType::ApprovalRequest);
+
+        snapshot_lines("update_details_with_rename", lines, 80, 12);
+    }
+
+    #[test]
+    fn ui_snapshot_wrap_behavior_insert() {
+        // Narrow width to force wrapping within our diff line rendering
+        let long_line = "this is a very long line that should wrap across multiple terminal columns and continue";
+
+        // Call the wrapping function directly so we can precisely control the width
+        let lines =
+            push_wrapped_diff_line(1, DiffLineType::Insert, long_line, DEFAULT_WRAP_COLS.into());
+
+        // Render into a small terminal to capture the visual layout
+        snapshot_lines("wrap_behavior_insert", lines, DEFAULT_WRAP_COLS + 10, 8);
+    }
+}
diff --git a/codex-rs/tui/src/history_cell.rs b/codex-rs/tui/src/history_cell.rs
index 95ed8efac2..b49e59972c 100644
--- a/codex-rs/tui/src/history_cell.rs
+++ b/codex-rs/tui/src/history_cell.rs
@@ -449,7 +449,7 @@ impl HistoryCell {
     }
 
     pub(crate) fn new_completed_mcp_tool_call(
-        num_cols: u16,
+        num_cols: usize,
         invocation: McpInvocation,
         duration: Duration,
         success: bool,
@@ -487,7 +487,7 @@ impl HistoryCell {
                                 format_and_truncate_tool_result(
                                     &text.text,
                                     TOOL_CALL_MAX_LINES,
-                                    num_cols as usize,
+                                    num_cols,
                                 )
                             }
                             mcp_types::ContentBlock::ImageContent(_) => {
@@ -848,7 +848,9 @@ impl HistoryCell {
             }
         };
 
-        let lines: Vec<Line<'static>> = create_diff_summary(title, changes);
+        let mut lines: Vec<Line<'static>> = create_diff_summary(title, &changes, event_type);
+
+        lines.push(Line::from(""));
 
         HistoryCell::PendingPatch {
             view: TextBlock::new(lines),
diff --git a/codex-rs/tui/src/lib.rs b/codex-rs/tui/src/lib.rs
index 27c850ca61..8f64f3247d 100644
--- a/codex-rs/tui/src/lib.rs
+++ b/codex-rs/tui/src/lib.rs
@@ -30,6 +30,7 @@ mod chatwidget;
 mod citation_regex;
 mod cli;
 mod colors;
+mod common;
 pub mod custom_terminal;
 mod diff_render;
 mod exec_command;
diff --git a/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__add_details.snap b/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__add_details.snap
new file mode 100644
index 0000000000..06fc8a68e8
--- /dev/null
+++ b/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__add_details.snap
@@ -0,0 +1,14 @@
+---
+source: tui/src/diff_render.rs
+expression: terminal.backend()
+---
+"proposed patch to 1 file (+2 -0)                                                "
+"  ⎿ README.md (+2 -0)                                                           "
+"    1     +first line                                                           "
+"    2     +second line                                                          "
+"                                                                                "
+"                                                                                "
+"                                                                                "
+"                                                                                "
+"                                                                                "
+"                                                                                "
diff --git a/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__update_details_with_rename.snap b/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__update_details_with_rename.snap
new file mode 100644
index 0000000000..0eebe09d73
--- /dev/null
+++ b/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__update_details_with_rename.snap
@@ -0,0 +1,16 @@
+---
+source: tui/src/diff_render.rs
+expression: terminal.backend()
+---
+"proposed patch to 1 file (+1 -1)                                                "
+"  ⎿ src/lib.rs → src/lib_new.rs (+1 -1)                                         "
+"    1     line one                                                              "
+"    2     -line two                                                             "
+"    2     +line two changed                                                     "
+"    3     line three                                                            "
+"                                                                                "
+"                                                                                "
+"                                                                                "
+"                                                                                "
+"                                                                                "
+"                                                                                "
diff --git a/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__wrap_behavior_insert.snap b/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__wrap_behavior_insert.snap
new file mode 100644
index 0000000000..641552d5a1
--- /dev/null
+++ b/codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__wrap_behavior_insert.snap
@@ -0,0 +1,12 @@
+---
+source: tui/src/diff_render.rs
+expression: terminal.backend()
+---
+"    1     +this is a very long line that should wrap across multiple terminal col         "
+"          umns and continue                                                               "
+"                                                                                          "
+"                                                                                          "
+"                                                                                          "
+"                                                                                          "
+"                                                                                          "
+"                                                                                          "
```

## Review Comments

### codex-rs/tui/src/diff_render.rs

- Created: 2025-08-11 21:14:21 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268030258

```diff
@@ -0,0 +1,354 @@
+use crossterm::terminal;
+use ratatui::style::Color;
+use ratatui::style::Modifier;
+use ratatui::style::Style;
+use ratatui::text::Line as RtLine;
+use ratatui::text::Span as RtSpan;
+use std::collections::HashMap;
+use std::path::PathBuf;
+
+use codex_core::protocol::FileChange;
+
+const DEFAULT_WRAP_COLS: usize = 96;
```

> Curious why `96`. I see `80` hardcoded for a number of things in `chatwidget.rs` (admittedly, it's not pulled out as a `const` there, but should be).

- Created: 2025-08-11 21:15:20 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268031810

```diff
@@ -0,0 +1,354 @@
+use crossterm::terminal;
+use ratatui::style::Color;
+use ratatui::style::Modifier;
+use ratatui::style::Style;
+use ratatui::text::Line as RtLine;
+use ratatui::text::Span as RtSpan;
+use std::collections::HashMap;
+use std::path::PathBuf;
+
+use codex_core::protocol::FileChange;
+
+const DEFAULT_WRAP_COLS: usize = 96;
+const SPACES_AFTER_LINE_NUMBER: usize = 6;
+
+pub(crate) fn render_patch_details(changes: &HashMap<PathBuf, FileChange>) -> Vec<RtLine<'static>> {
+    let mut out: Vec<RtLine<'static>> = Vec::new();
+    let term_cols: usize = terminal::size()
+        .map(|(w, _)| w as usize)
+        .unwrap_or(DEFAULT_WRAP_COLS);
+
+    let mut is_first_file = true;
+    for (path, change) in changes.iter() {
```

> Can also do `enumerate()` and then you have an extra `index` param and then inside the loop can do `let is_first_file = index == 0;`

- Created: 2025-08-11 21:27:17 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268061649

```diff
@@ -0,0 +1,354 @@
+use crossterm::terminal;
+use ratatui::style::Color;
+use ratatui::style::Modifier;
+use ratatui::style::Style;
+use ratatui::text::Line as RtLine;
+use ratatui::text::Span as RtSpan;
+use std::collections::HashMap;
+use std::path::PathBuf;
+
+use codex_core::protocol::FileChange;
+
+const DEFAULT_WRAP_COLS: usize = 96;
+const SPACES_AFTER_LINE_NUMBER: usize = 6;
+
+pub(crate) fn render_patch_details(changes: &HashMap<PathBuf, FileChange>) -> Vec<RtLine<'static>> {
+    let mut out: Vec<RtLine<'static>> = Vec::new();
+    let term_cols: usize = terminal::size()
+        .map(|(w, _)| w as usize)
+        .unwrap_or(DEFAULT_WRAP_COLS);
+
+    let mut is_first_file = true;
+    for (path, change) in changes.iter() {
+        // Add separator only between files (not at the very start)
+        if !is_first_file {
+            out.push(RtLine::from(vec![
+                RtSpan::raw("    "),
+                RtSpan::styled("...", style_dim()),
+            ]));
+        }
+        match change {
+            FileChange::Add { content } => {
+                let ln_width = usize::max(2, digits_len(content.lines().count()));
+                for (i, raw) in content.lines().enumerate() {
+                    let ln = i + 1;
+                    push_wrapped_diff_line(
+                        &mut out,
+                        ln,
+                        '+',
+                        raw,
+                        Some(style_add()),
+                        term_cols,
+                        ln_width,
+                    );
+                }
+            }
+            FileChange::Delete => {
+                let original = std::fs::read_to_string(path).unwrap_or_default();
+                let ln_width = usize::max(2, digits_len(original.lines().count()));
+                for (i, raw) in original.lines().enumerate() {
+                    let ln = i + 1;
+                    push_wrapped_diff_line(
+                        &mut out,
+                        ln,
+                        '-',
+                        raw,
+                        Some(style_del()),
+                        term_cols,
+                        ln_width,
+                    );
+                }
+            }
+            FileChange::Update {
+                unified_diff,
+                move_path: _,
+            } => {
+                if let Ok(patch) = diffy::Patch::from_str(unified_diff) {
+                    for h in patch.hunks() {
+                        // determine a reasonable ln field width for this hunk
+                        let old_end = h.old_range().end();
+                        let new_end = h.new_range().end();
+                        let ln_width = usize::max(2, digits_len(old_end.max(new_end)));
+
+                        let mut old_ln = h.old_range().start();
+                        let mut new_ln = h.new_range().start();
+                        for l in h.lines() {
+                            match l {
+                                diffy::Line::Insert(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    push_wrapped_diff_line(
+                                        &mut out,
+                                        new_ln,
+                                        '+',
+                                        s,
+                                        Some(style_add()),
+                                        term_cols,
+                                        ln_width,
+                                    );
+                                    new_ln += 1;
+                                }
+                                diffy::Line::Delete(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    push_wrapped_diff_line(
+                                        &mut out,
+                                        old_ln,
+                                        '-',
+                                        s,
+                                        Some(style_del()),
+                                        term_cols,
+                                        ln_width,
+                                    );
+                                    old_ln += 1;
+                                }
+                                diffy::Line::Context(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    push_wrapped_diff_line(
+                                        &mut out, new_ln, ' ', s, None, term_cols, ln_width,
+                                    );
+                                    old_ln += 1;
+                                    new_ln += 1;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        out.push(RtLine::from(RtSpan::raw("")));
+        is_first_file = false;
+    }
+
+    out
+}
+
+pub(crate) fn create_diff_summary(
+    title: &str,
+    changes: &HashMap<PathBuf, FileChange>,
+) -> Vec<RtLine<'static>> {
+    struct FileSummary {
+        display_path: String,
+        added: usize,
+        removed: usize,
+    }
+
+    let count_from_unified = |diff: &str| -> (usize, usize) {
+        if let Ok(patch) = diffy::Patch::from_str(diff) {
+            patch
+                .hunks()
+                .iter()
+                .flat_map(|h| h.lines())
+                .fold((0, 0), |(a, d), l| match l {
+                    diffy::Line::Insert(_) => (a + 1, d),
+                    diffy::Line::Delete(_) => (a, d + 1),
+                    _ => (a, d),
+                })
+        } else {
+            // Fallback: manual scan to preserve counts even for unparseable diffs
+            let mut adds = 0usize;
+            let mut dels = 0usize;
+            for l in diff.lines() {
+                if l.starts_with("+++") || l.starts_with("---") || l.starts_with("@@") {
+                    continue;
+                }
+                match l.as_bytes().first() {
+                    Some(b'+') => adds += 1,
+                    Some(b'-') => dels += 1,
+                    _ => {}
+                }
+            }
+            (adds, dels)
+        }
+    };
+
+    let mut files: Vec<FileSummary> = Vec::new();
+    for (path, change) in changes.iter() {
+        match change {
+            FileChange::Add { content } => files.push(FileSummary {
+                display_path: path.display().to_string(),
+                added: content.lines().count(),
+                removed: 0,
+            }),
+            FileChange::Delete => files.push(FileSummary {
+                display_path: path.display().to_string(),
+                added: 0,
+                removed: std::fs::read_to_string(path)
+                    .ok()
+                    .map(|s| s.lines().count())
+                    .unwrap_or(0),
+            }),
+            FileChange::Update {
+                unified_diff,
+                move_path,
+            } => {
+                let (added, removed) = count_from_unified(unified_diff);
+                let display_path = if let Some(new_path) = move_path {
+                    format!("{} → {}", path.display(), new_path.display())
+                } else {
+                    path.display().to_string()
+                };
+                files.push(FileSummary {
+                    display_path,
+                    added,
+                    removed,
+                });
+            }
+        }
+    }
+
+    let file_count = files.len();
+    let total_added: usize = files.iter().map(|f| f.added).sum();
+    let total_removed: usize = files.iter().map(|f| f.removed).sum();
+    let noun = if file_count == 1 { "file" } else { "files" };
+
+    let mut out: Vec<RtLine<'static>> = Vec::new();
+
+    // Header
+    let mut header_spans: Vec<RtSpan<'static>> = Vec::new();
+    header_spans.push(RtSpan::styled(
+        title.to_owned(),
+        Style::default()
+            .fg(Color::Magenta)
+            .add_modifier(Modifier::BOLD),
+    ));
+    header_spans.push(RtSpan::raw(" to "));
+    header_spans.push(RtSpan::raw(format!("{file_count} {noun} ")));
+    header_spans.push(RtSpan::raw("("));
+    header_spans.push(RtSpan::styled(
+        format!("+{total_added}"),
+        Style::default().fg(Color::Green),
+    ));
+    header_spans.push(RtSpan::raw(" "));
+    header_spans.push(RtSpan::styled(
+        format!("-{total_removed}"),
+        Style::default().fg(Color::Red),
+    ));
+    header_spans.push(RtSpan::raw(")"));
+    out.push(RtLine::from(header_spans));
+
+    // Dimmed per-file lines with prefix
+    for (idx, f) in files.iter().enumerate() {
+        let mut spans: Vec<RtSpan<'static>> = Vec::new();
+        spans.push(RtSpan::raw(f.display_path.clone()));
+        spans.push(RtSpan::raw(" ("));
+        spans.push(RtSpan::styled(
+            format!("+{}", f.added),
+            Style::default().fg(Color::Green),
+        ));
+        spans.push(RtSpan::raw(" "));
+        spans.push(RtSpan::styled(
+            format!("-{}", f.removed),
+            Style::default().fg(Color::Red),
+        ));
+        spans.push(RtSpan::raw(")"));
+
+        let mut line = RtLine::from(spans);
+        let prefix = if idx == 0 { "  ⎿ " } else { "    " };
+        line.spans.insert(0, prefix.into());
+        line.spans
+            .iter_mut()
+            .for_each(|span| span.style = span.style.add_modifier(Modifier::DIM));
+        out.push(line);
+    }
+
+    out
+}
+
+fn push_wrapped_diff_line(
+    out: &mut Vec<RtLine<'static>>,
+    line_number: usize,
+    sign: char,
+    text: &str,
+    bg_style: Option<Style>,
+    term_cols: usize,
+    _ln_width: usize,
+) {
+    let indent = "    ";
+    let ln_str = line_number.to_string();
+    let mut remaining: &str = text;
+
+    // Reserve a fixed number of spaces after the line number so that content starts
+    // at a consistent column. The sign ("+"/"-") is rendered as part of the content
+    // with the same background as the edit, not as a separate dimmed column.
+    let gap_after_ln = SPACES_AFTER_LINE_NUMBER.saturating_sub(ln_str.len());
+    let first_prefix_cols = indent.len() + ln_str.len() + gap_after_ln;
+    let cont_prefix_cols = indent.len() + ln_str.len() + gap_after_ln;
+
+    let mut first = true;
+    while !remaining.is_empty() {
+        let prefix_cols = if first {
+            first_prefix_cols
+        } else {
+            cont_prefix_cols
+        };
+        let available = term_cols.saturating_sub(prefix_cols).max(1);
+        let take = remaining
+            .char_indices()
+            .nth(available)
+            .map(|(i, _)| i)
+            .unwrap_or_else(|| remaining.len());
+        let (chunk, rest) = remaining.split_at(take);
+        remaining = rest;
+
+        if first {
+            let mut spans: Vec<RtSpan<'static>> = Vec::new();
+            spans.push(RtSpan::raw(indent));
+            spans.push(RtSpan::styled(ln_str.clone(), style_dim()));
+            spans.push(RtSpan::raw(" ".repeat(gap_after_ln)));
+
+            // Prefix the content with the sign if it is an insertion or deletion, and color
+            // the sign with the same background as the edited text.
+            let display_chunk = match sign {
+                '+' | '-' => {
+                    let mut s = String::with_capacity(1 + chunk.len());
+                    s.push(sign);
+                    s.push_str(chunk);
+                    s
+                }
+                _ => chunk.to_string(),
+            };
+
+            let content_span = match bg_style {
+                Some(style) => RtSpan::styled(display_chunk, style),
+                None => RtSpan::raw(display_chunk),
+            };
+            spans.push(content_span);
+            out.push(RtLine::from(spans));
+            first = false;
+        } else {
+            let hang_prefix = format!(
+                "{indent}{}{}",
+                " ".repeat(ln_str.len()),
+                " ".repeat(gap_after_ln)
+            );
+            let content_span = match bg_style {
+                Some(style) => RtSpan::styled(chunk.to_string(), style),
+                None => RtSpan::raw(chunk.to_string()),
+            };
+            out.push(RtLine::from(vec![RtSpan::raw(hang_prefix), content_span]));
+        }
+    }
+}
+
+fn style_dim() -> Style {
+    Style::default().add_modifier(Modifier::DIM)
+}
+
+fn style_add() -> Style {
+    Style::default().bg(Color::Green)
+}
+
+fn style_del() -> Style {
+    Style::default().bg(Color::Red)
+}
+
+#[inline]
+fn digits_len(n: usize) -> usize {
```

> I asked GPT-5 and it recommened:
> 
> ```rust
> fn decimal_len(n: usize) -> usize {
>     if n == 0 { 1 } else { n.ilog10() as usize + 1 }
> }
> ```
> 
> claiming:
> 
> > That last one is both concise and efficient—internally it uses hardware intrinsics to count leading zeros and computes log10 without looping. On modern CPUs, that’s about as fast as it gets.

- Created: 2025-08-11 21:30:02 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268065937

```diff
@@ -0,0 +1,354 @@
+use crossterm::terminal;
+use ratatui::style::Color;
+use ratatui::style::Modifier;
+use ratatui::style::Style;
+use ratatui::text::Line as RtLine;
+use ratatui::text::Span as RtSpan;
+use std::collections::HashMap;
+use std::path::PathBuf;
+
+use codex_core::protocol::FileChange;
+
+const DEFAULT_WRAP_COLS: usize = 96;
+const SPACES_AFTER_LINE_NUMBER: usize = 6;
+
+pub(crate) fn render_patch_details(changes: &HashMap<PathBuf, FileChange>) -> Vec<RtLine<'static>> {
```

> Can we get some sort of test for this? Is `.snap` the way to go?
> 
> Maybe we need to introduce macros to make it easier to express the expected value?

- Created: 2025-08-11 23:42:20 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268237398

```diff
@@ -0,0 +1,354 @@
+use crossterm::terminal;
+use ratatui::style::Color;
+use ratatui::style::Modifier;
+use ratatui::style::Style;
+use ratatui::text::Line as RtLine;
+use ratatui::text::Span as RtSpan;
+use std::collections::HashMap;
+use std::path::PathBuf;
+
+use codex_core::protocol::FileChange;
+
+const DEFAULT_WRAP_COLS: usize = 96;
+const SPACES_AFTER_LINE_NUMBER: usize = 6;
+
+pub(crate) fn render_patch_details(changes: &HashMap<PathBuf, FileChange>) -> Vec<RtLine<'static>> {
```

> @aibrahim-oai I thought you brought the first `.snap` file to the repo!
> 
> https://github.com/openai/codex/blob/main/codex-rs/tui/src/bottom_pane/snapshots/codex_tui__bottom_pane__chat_composer__tests__large.snap

- Created: 2025-08-12 00:56:16 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268322908

```diff
@@ -142,11 +145,259 @@ pub(crate) fn create_diff_summary(
         let mut line = RtLine::from(spans);
         let prefix = if idx == 0 { "  ⎿ " } else { "    " };
         line.spans.insert(0, prefix.into());
-        line.spans.iter_mut().for_each(|span| {
-            span.style = span.style.add_modifier(Modifier::DIM);
-        });
+        line.spans
+            .iter_mut()
+            .for_each(|span| span.style = span.style.add_modifier(Modifier::DIM));
         out.push(line);
     }
 
+    let show_details = matches!(
+        event_type,
+        PatchEventType::ApplyBegin {
+            auto_approved: true
+        } | PatchEventType::ApprovalRequest
+    );
+
+    if show_details {
+        out.extend(render_patch_details(changes));
+    }
+
     out
 }
+
+fn render_patch_details(changes: &HashMap<PathBuf, FileChange>) -> Vec<RtLine<'static>> {
+    let mut out: Vec<RtLine<'static>> = Vec::new();
+    let term_cols: usize = terminal::size()
+        .map(|(w, _)| w as usize)
+        .unwrap_or(DEFAULT_WRAP_COLS);
+
+    for (index, (path, change)) in changes.iter().enumerate() {
+        let is_first_file = index == 0;
+        // Add separator only between files (not at the very start)
+        if !is_first_file {
+            out.push(RtLine::from(vec![
+                RtSpan::raw("    "),
+                RtSpan::styled("...", style_dim()),
+            ]));
+        }
+        match change {
+            FileChange::Add { content } => {
+                for (i, raw) in content.lines().enumerate() {
+                    let ln = i + 1;
+                    push_wrapped_diff_line(&mut out, ln, DiffLineType::Insert, raw, term_cols);
+                }
+            }
+            FileChange::Delete => {
+                let original = std::fs::read_to_string(path).unwrap_or_default();
+                for (i, raw) in original.lines().enumerate() {
+                    let ln = i + 1;
+                    push_wrapped_diff_line(&mut out, ln, DiffLineType::Delete, raw, term_cols);
+                }
+            }
+            FileChange::Update {
+                unified_diff,
+                move_path: _,
+            } => {
+                if let Ok(patch) = diffy::Patch::from_str(unified_diff) {
+                    for h in patch.hunks() {
+                        let mut old_ln = h.old_range().start();
+                        let mut new_ln = h.new_range().start();
+                        for l in h.lines() {
+                            match l {
+                                diffy::Line::Insert(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    push_wrapped_diff_line(
+                                        &mut out,
+                                        new_ln,
+                                        DiffLineType::Insert,
+                                        s,
+                                        term_cols,
+                                    );
+                                    new_ln += 1;
+                                }
+                                diffy::Line::Delete(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    push_wrapped_diff_line(
+                                        &mut out,
+                                        old_ln,
+                                        DiffLineType::Delete,
+                                        s,
+                                        term_cols,
+                                    );
+                                    old_ln += 1;
+                                }
+                                diffy::Line::Context(text) => {
+                                    let s = text.trim_end_matches('\n');
+                                    push_wrapped_diff_line(
+                                        &mut out,
+                                        new_ln,
+                                        DiffLineType::Context,
+                                        s,
+                                        term_cols,
+                                    );
+                                    old_ln += 1;
+                                    new_ln += 1;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        out.push(RtLine::from(RtSpan::raw("")));
+    }
+
+    out
+}
+
+fn push_wrapped_diff_line(
+    out: &mut Vec<RtLine<'static>>,
+    line_number: usize,
+    kind: DiffLineType,
+    text: &str,
+    term_cols: usize,
+) {
+    let indent = "    ";
+    let ln_str = line_number.to_string();
+    let mut remaining: &str = text;
+
+    // Reserve a fixed number of spaces after the line number so that content starts
+    // at a consistent column. The sign ("+"/"-") is rendered as part of the content
+    // with the same background as the edit, not as a separate dimmed column.
+    let gap_after_ln = SPACES_AFTER_LINE_NUMBER.saturating_sub(ln_str.len());
+    let first_prefix_cols = indent.len() + ln_str.len() + gap_after_ln;
+    let cont_prefix_cols = indent.len() + ln_str.len() + gap_after_ln;
+
+    let mut first = true;
+    let (sign_opt, bg_style) = match kind {
+        DiffLineType::Insert => (Some('+'), Some(style_add())),
+        DiffLineType::Delete => (Some('-'), Some(style_del())),
+        DiffLineType::Context => (None, None),
+    };
+    while !remaining.is_empty() {
+        let prefix_cols = if first {
+            first_prefix_cols
+        } else {
+            cont_prefix_cols
+        };
+        let available = term_cols.saturating_sub(prefix_cols).max(1);
+        let take = remaining
+            .char_indices()
+            .nth(available)
+            .map(|(i, _)| i)
+            .unwrap_or_else(|| remaining.len());
+        let (chunk, rest) = remaining.split_at(take);
+        remaining = rest;
+
+        if first {
+            let mut spans: Vec<RtSpan<'static>> = Vec::new();
+            spans.push(RtSpan::raw(indent));
+            spans.push(RtSpan::styled(ln_str.clone(), style_dim()));
+            spans.push(RtSpan::raw(" ".repeat(gap_after_ln)));
+
+            // Prefix the content with the sign if it is an insertion or deletion, and color
+            // the sign with the same background as the edited text.
+            let display_chunk = match sign_opt {
+                Some(sign_char) => {
+                    let mut s = String::with_capacity(1 + chunk.len());
+                    s.push(sign_char);
+                    s.push_str(chunk);
+                    s
```

> FYI, probably more efficient as `format!()`?

### codex-rs/tui/src/history_cell.rs

- Created: 2025-08-11 23:45:37 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268240671

```diff
@@ -446,7 +446,7 @@ impl HistoryCell {
     }
 
     pub(crate) fn new_completed_mcp_tool_call(
-        num_cols: u16,
```

> I think this was `u16` because a number of Ratatui APIs expected `u16`, though I don't feel strongly about this.

### codex-rs/tui/src/snapshots/codex_tui__diff_render__tests__add_details.snap

- Created: 2025-08-12 00:00:09 UTC | Link: https://github.com/openai/codex/pull/2050#discussion_r2268254297

```diff
@@ -0,0 +1,14 @@
+---
+source: tui/src/diff_render.rs
+expression: terminal.backend()
+---
+"proposed patch to 1 file (+2 -0)                                                "
```

> Hmm, so one thing I did not take into account is that this loses style information. i.e., this test doesn't confirm where red and green backgrounds are applied.
> 
> I asked chat and it suggested comparing with JSON instead:
> 
> ```
> {
>   "width": 16,
>   "height": 3,
>   "lines": [
>     [
>       { "text": "Hello world", "fg": "Red", "bg": null, "mods": ["bold"] },
>       { "text": "!", "fg": "Cyan", "bg": null, "mods": [] },
>       { "text": "     ", "fg": null, "bg": null, "mods": [] }
>     ],
>     [
>       { "text": "", "fg": null, "bg": null, "mods": [] }
>     ],
>     [
>       { "text": "", "fg": null, "bg": null, "mods": [] }
>     ]
>   ]
> }
> ```
> 
> And using a helper like this to generate the JSON:
> 
> ```
> use ratatui::{
>     buffer::Buffer,
>     layout::Rect,
>     style::{Color, Modifier, Style},
>     widgets::{Paragraph, Widget},
> };
> use serde::Serialize;
> 
> #[derive(Serialize)]
> struct StyledSpan {
>     text: String,
>     fg: Option<String>,
>     bg: Option<String>,
>     mods: Vec<&'static str>,
> }
> 
> #[derive(Serialize)]
> struct Snapshot {
>     width: u16,
>     height: u16,
>     lines: Vec<Vec<StyledSpan>>,
> }
> 
> fn color_str(c: Color) -> Option<String> {
>     use Color::*;
>     match c {
>         Reset => None,
>         Black => Some("Black".into()),
>         Red => Some("Red".into()),
>         Green => Some("Green".into()),
>         Yellow => Some("Yellow".into()),
>         Blue => Some("Blue".into()),
>         Magenta => Some("Magenta".into()),
>         Cyan => Some("Cyan".into()),
>         Gray => Some("Gray".into()),
>         DarkGray => Some("DarkGray".into()),
>         LightRed => Some("LightRed".into()),
>         LightGreen => Some("LightGreen".into()),
>         LightYellow => Some("LightYellow".into()),
>         LightBlue => Some("LightBlue".into()),
>         LightMagenta => Some("LightMagenta".into()),
>         LightCyan => Some("LightCyan".into()),
>         White => Some("White".into()),
>         Rgb(r, g, b) => Some(format!("rgb({},{},{})", r, g, b)),
>         Indexed(i) => Some(format!("idx({})", i)),
>     }
> }
> 
> fn mods_vec(m: Modifier) -> Vec<&'static str> {
>     let all = [
>         (Modifier::BOLD, "bold"),
>         (Modifier::ITALIC, "italic"),
>         (Modifier::UNDERLINED, "underline"),
>         (Modifier::REVERSED, "reverse"),
>         (Modifier::DIM, "dim"),
>         (Modifier::CROSSED_OUT, "crossed"),
>         (Modifier::SLOW_BLINK, "slow_blink"),
>         (Modifier::RAPID_BLINK, "rapid_blink"),
>         (Modifier::HIDDEN, "hidden"),
>     ];
>     all.iter().filter_map(|(flag, name)| if m.contains(*flag) { Some(*name) } else { None }).collect()
> }
> 
> /// Compress each row of the Buffer into runs of same-style cells.
> fn buffer_to_snapshot(buf: &Buffer) -> Snapshot {
>     let w = buf.area.width;
>     let h = buf.area.height;
>     let mut lines: Vec<Vec<StyledSpan>> = Vec::with_capacity(h as usize);
> 
>     for y in 0..h {
>         let mut spans: Vec<StyledSpan> = Vec::new();
>         let mut cur_style: Option<Style> = None;
>         let mut cur_text = String::new();
> 
>         for x in 0..w {
>             let cell = &buf[(x, y)];
>             let s = cell.style;
> 
>             if cur_style.map_or(true, |cs| cs != s) {
>                 // flush previous run
>                 if !cur_text.is_empty() {
>                     let st = cur_style.unwrap();
>                     spans.push(StyledSpan {
>                         text: cur_text.clone(),
>                         fg: color_str(st.fg),
>                         bg: color_str(st.bg),
>                         mods: mods_vec(st.add_modifier),
>                     });
>                     cur_text.clear();
>                 }
>                 cur_style = Some(s);
>             }
>             cur_text.push_str(&cell.symbol);
>         }
> 
>         // flush last run on the line
>         if let Some(st) = cur_style {
>             spans.push(StyledSpan {
>                 text: cur_text,
>                 fg: color_str(st.fg),
>                 bg: color_str(st.bg),
>                 mods: mods_vec(st.add_modifier),
>             });
>         }
> 
>         // (Optional) trim trailing spaces-only final span for prettier diffs:
>         if let Some(last) = spans.last_mut() {
>             if last.text.chars().all(|c| c == ' ') {
>                 // if you want exact layout fidelity, comment this out
>                 while last.text.ends_with(' ') {
>                     last.text.pop();
>                 }
>             }
>         }
> 
>         lines.push(spans);
>     }
> 
>     Snapshot { width: w, height: h, lines }
> }
> 
> #[cfg(test)]
> mod tests {
>     use super::*;
>     use insta::assert_json_snapshot;
> 
>     #[test]
>     fn paragraph_as_styled_spans() {
>         let mut buf = Buffer::empty(Rect::new(0, 0, 16, 3));
>         let widget = Paragraph::new("Hello world")
>             .style(Style::default().fg(Color::Red).add_modifier(Modifier::BOLD));
>         widget.render(buf.area, &mut buf);
> 
>         // Add a differently-styled bit so you can see span splitting:
>         let mut cell = &mut buf[(11, 0)];
>         cell.set_symbol("!");
>         cell.set_style(Style::default().fg(Color::Cyan));
> 
>         let snap = buffer_to_snapshot(&buf);
>         assert_json_snapshot!("paragraph_styled_spans", &snap);
>     }
> }
> ```
> 
> I think this sort of effort is outside the scope of this PR, but would be generally helpful for someone to build in a follow up.
> 
> /cc @easong-openai who I believe has also been thinking about how to have better UI tests.